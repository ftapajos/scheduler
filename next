#!/usr/bin/env python

from math import exp
from tasklib import TaskWarrior
import subprocess
import time
from datetime import timedelta, datetime, UTC, timezone
from sys import argv
import itertools
import json

debug = ("./" in argv[0])

tagless = 'TAGLESSTASK'


def extract_tags_from(task):
    tags = []

    # Extract attributes for use as tags.
    if task['project'] is not None:
        tags.append(task['project'])

    if task['tags'] is not None:
        if type(task['tags']) is str:
            # Usage of tasklib (e.g. in taskpirate) converts the tag list into 
            # a string
            # If this is the case, convert it back into a list first
            # See https://github.com/tbabej/taskpirate/issues/11
            tags.extend(task['tags'].split(','))
        else:
            tags.extend(task['tags'])
    
    if len(tags) == 0:
        tags.append(tagless)
    return tags


def calculate_tag_sum(tags, taskDictionary, dictionary):
    tagSum = {}
    tids = taskDictionary.keys()
    for tag in tags:
        tagSum[tag] = sum([
            dictionary[tid] for tid in tids
            if tag in extract_tags_from(tDict[tid])
            ])
    return tagSum


def get_total_time_tags(tags):
    day = json.loads(subprocess.check_output(
            ['timew', 'export', ':day']
            ))

    total_time = 0
    for event in day:
        if set(tags).intersection(set(event['tags'])):
            start = datetime.strptime(
                    event['start'], "%Y%m%dT%H%M%SZ"
                    ).replace(tzinfo=timezone.utc)
            if 'end' in event:
                end = datetime.strptime(
                        event['end'], "%Y%m%dT%H%M%SZ"
                        ).replace(tzinfo=timezone.utc)
            else:
                end = datetime.now(UTC)
            total_time += (end-start).total_seconds()
    return total_time


def get_duration_on(tags):
    if tagless in tags:
        tags.remove(tagless)

    if len(tags) <= 0:
        return 0

    summary = subprocess.check_output(
            ['timew', 'summary'] + tags
            ).splitlines()

    if len(summary) > 2:
        t = time.strptime(summary[-2].decode("utf-8").strip(), "%H:%M:%S")
        return timedelta(hours=t.tm_hour, minutes=t.tm_min,
                         seconds=t.tm_sec).total_seconds()

    else:
        return timedelta().total_seconds()


def get_shares(executedTime, virtualTime,
               totalExecutedTime, totalVirtualTime):
    assert len(executedTime) == len(virtualTime)
    assert executedTime.keys() == virtualTime.keys()

    keys = executedTime.keys()
    # Calcula executed shares
    executedShares = {key: executedTime[key]/totalExecutedTime
                      if totalExecutedTime > 0 else 0
                      for key in keys}

    # Calcula shares
    shares = {key: virtualTime[key]/totalVirtualTime for key in keys}
    return (shares, executedShares)


# Obtém tarefas desbloqueadas com os filtros
tw = TaskWarrior()
filterString = "(" + ' '.join(argv[1:]) + ") +UNBLOCKED"
tasks = tw.tasks.filter(filterString).pending()

if len(tasks) <= 0:
    print("Taskless")
    subprocess.run(["task", "ls", filterString])
    quit()

# Obtém todas as tags
tags = set([tag for task in tasks for tag in extract_tags_from(task)])

# Calcula virtual times
virtualTime = {}
tDict = {}
for task in tasks:
    tDict[task['id']] = task
    virtualTime[task['id']] = exp(task['urgency'])

# Calcula executedTime por task
executedTime = {tid: get_duration_on(
            [tDict[tid]['description']] + extract_tags_from(tDict[tid])
            ) for tid in virtualTime.keys()}

executedTimeTag = {tag: get_duration_on([tag]) for tag in tags}

totalTimeTags = get_total_time_tags(executedTimeTag.keys())

# Retorna next, se o tempo total for inferior a 25min
if totalTimeTags < 25*60:
    print("Little sampled time (",
          int(totalTimeTags/60), "min)", sep='')
    subprocess.run(["task", "next", filterString, "limit:1"])
    quit()

totalVirtualTime = sum(virtualTime.values())

# Calcula virtual time de cada tag
virtualTimeTag = calculate_tag_sum(tags, tDict, virtualTime)
sharesTag, executedSharesTag = get_shares(
        executedTimeTag, virtualTimeTag, totalTimeTags, totalVirtualTime
        )

totalExecutedTime = sum(executedTime.values())

tag_correction = {}
for tag in sharesTag.keys():
    tag_correction[tag] = executedSharesTag[tag]/sharesTag[tag]
    if debug:
        print(tag, executedSharesTag[tag], sharesTag[tag], tag_correction[tag])

# Calcula tempos totais
tids = tDict.keys()
for tid in tids:
    for tag in extract_tags_from(tDict[tid]):
        virtualTime[tid] /= (tag_correction[tag] if tag_correction[tag] != 0 else 1)

totalVirtualTime = sum(virtualTime.values())


# Organiza por diferenças
shares, executedShares = get_shares(
        executedTime, virtualTime, totalExecutedTime, totalVirtualTime
        )

difference = {
        key: shares[key]-executedShares[key]
        for key in shares.keys()
        }

if debug:
    for tid in sorted(difference, key=difference.get, reverse=True):
        print(int(100*shares[tid]), int(100*executedShares[tid]),
#              int(executedTime[tid]*100/totalExecutedTime if totalExecutedTime >0 \N),
              int(100*difference[tid]), tDict[tid])

tid = max(difference, key=difference.get)

print("Necessário: ",
      int(shares[tid]*10000)/100, "%",
      sep='')
print("Executado:  ",
      int(executedTime[tid]*10000/totalExecutedTime)/100
      if totalExecutedTime > 0 else 0, "%",
      sep='')

subprocess.run(["task", "ls", str(tid)])
