#!/usr/bin/env python

from math import exp
from tasklib import TaskWarrior
import subprocess
import time
from datetime import timedelta
from sys import argv


def extract_tags_from(task):
    tags = []

    # Extract attributes for use as tags.
    if task['project'] is not None:
        tags.append(task['project'])

    if task['tags'] is not None:
        if type(task['tags']) is str:
            # Usage of tasklib (e.g. in taskpirate) converts the tag list into 
            # a string
            # If this is the case, convert it back into a list first
            # See https://github.com/tbabej/taskpirate/issues/11
            tags.extend(task['tags'].split(','))
        else:
            tags.extend(task['tags'])
    
    if len(tags) == 0:
        tags.append('TAGLESSTASK')
    return tags


def calculate_tag_sum(tags, taskDictionary, dictionary):
    tagSum = {}
    tids = taskDictionary.keys()
    for tag in tags:
        tagSum[tag] = sum([
            dictionary[tid] for tid in tids
            if tag in extract_tags_from(tDict[tid])
            ])
    return tagSum


def get_duration_on(tags):
    summary = subprocess.check_output(
            ['timew', 'summary'] + tags
            ).splitlines()

    if len(summary) > 2:
        t = time.strptime(summary[-2].decode("utf-8").strip(), "%H:%M:%S")
        return timedelta(hours=t.tm_hour, minutes=t.tm_min,
                         seconds=t.tm_sec).total_seconds()

    else:
        return timedelta().total_seconds()


def get_shares(executedTime, virtualTime,
               totalExecutedTime, totalVirtualTime):
    assert len(executedTime) == len(virtualTime)
    assert executedTime.keys() == virtualTime.keys()

    keys = executedTime.keys()
    # Calcula executed shares
    executedShares = {key: executedTime[key]/totalExecutedTime
                      if totalExecutedTime > 0 else 0
                      for key in keys}

    # Calcula shares
    shares = {key: virtualTime[key]/totalVirtualTime for key in keys}
    return (shares, executedShares)


# Obtém tarefas desbloqueadas com os filtros
tw = TaskWarrior()
filterString = ' '.join(argv[1:])
tasks = tw.tasks.filter('+UNBLOCKED').filter(filterString).pending()

if len(tasks) <= 0:
    print("Taskless")
    subprocess.run(["task", "ls", filterString])
    quit()

# Obtém todas as tags
tags = set([tag for task in tasks for tag in extract_tags_from(task)])

# Calcula virtual times
virtualTime = {}
tDict = {}
for task in tasks:
    tDict[task['id']] = task
    virtualTime[task['id']] = exp(task['urgency'])

# Calcula executedTime por task
executedTime = {tid: get_duration_on(
            [tDict[tid]['description']] + extract_tags_from(tDict[tid])
            ) for tid in virtualTime.keys()}

executedTimeTag = {tag: get_duration_on([tag]) for tag in tags}

# Retorna next, se o tempo total for inferior a 25min
if sum(executedTimeTag.values()) < 25*60:
    print("Little sampled time (",
          int(sum(executedTime.values())/60), "min)", sep='')
    subprocess.run(["task", "next", filterString, "limit:1"])
    quit()

# Calcula tempos totais
totalVirtualTime = sum(virtualTime.values())
totalExecutedTime = sum(executedTime.values())

# Calcula virtual time de cada tag
virtualTimeTag = calculate_tag_sum(tags, tDict, virtualTime)
sharesTag, executedSharesTag = get_shares(
        executedTimeTag, virtualTimeTag, totalExecutedTime, totalVirtualTime
        )

# Organiza por diferenças
shares, executedShares = get_shares(
        executedTime, virtualTime, totalExecutedTime, totalVirtualTime
        )

combinedShares = {}
combinedExecutedShares = {}
tids = tDict.keys()
for tag in tags:
    for tid in tids:
        if tag in extract_tags_from(tDict[tid]):
            combinedShares[(tag, tid)] = shares[tid] * sharesTag[tag]
            combinedExecutedShares[(tag, tid)] =\
                executedShares[tid] * executedSharesTag[tag]

difference = {
        key: combinedShares[key]-combinedExecutedShares[key]
        for key in combinedShares.keys()
        }
tidTuple = sorted(difference, key=difference.get, reverse=True)

# Processa a maior diferença
tag = tidTuple[0][0]
tid = tidTuple[0][1]
print("Necessário: ",
      int(combinedShares[tidTuple[0]]*10000)/100, "% (tarefa), ",
      int(sharesTag[tag]*10000)/100, "% (", tag, ")",
      sep='')
print("Executado:  ",
      int(combinedExecutedShares[tidTuple[0]]*10000)/100, "% (tarefa), ",
      int(executedSharesTag[tag]*10000)/100, "% (", tag, ")",
      sep='')

subprocess.run(["task", "ls", str(tid)])
