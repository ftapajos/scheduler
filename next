#!/usr/bin/env python

from math import exp
from tasklib import TaskWarrior
import subprocess
import time
from datetime import timedelta
from sys import argv
import itertools


def extract_tags_from(task):
    tags = []

    # Extract attributes for use as tags.
    if task['project'] is not None:
        tags.append(task['project'])

    if task['tags'] is not None:
        if type(task['tags']) is str:
            # Usage of tasklib (e.g. in taskpirate) converts the tag list into 
            # a string
            # If this is the case, convert it back into a list first
            # See https://github.com/tbabej/taskpirate/issues/11
            tags.extend(task['tags'].split(','))
        else:
            tags.extend(task['tags'])
    
    if len(tags) == 0:
        tags.append('TAGLESSTASK')
    return tags


def calculate_tag_sum(tags, taskDictionary, dictionary):
    tagSum = {}
    tids = taskDictionary.keys()
    for tag in tags:
        tagSum[tag] = sum([
            dictionary[tid] for tid in tids
            if tag in extract_tags_from(tDict[tid])
            ])
    return tagSum


def get_duration_on(tags):
    summary = subprocess.check_output(
            ['timew', 'summary'] + tags
            ).splitlines()

    if len(summary) > 2:
        t = time.strptime(summary[-2].decode("utf-8").strip(), "%H:%M:%S")
        return timedelta(hours=t.tm_hour, minutes=t.tm_min,
                         seconds=t.tm_sec).total_seconds()

    else:
        return timedelta().total_seconds()


def get_shares(executedTime, virtualTime,
               totalExecutedTime, totalVirtualTime):
    assert len(executedTime) == len(virtualTime)
    assert executedTime.keys() == virtualTime.keys()

    keys = executedTime.keys()
    # Calcula executed shares
    executedShares = {key: executedTime[key]/totalExecutedTime
                      if totalExecutedTime > 0 else 0
                      for key in keys}

    # Calcula shares
    shares = {key: virtualTime[key]/totalVirtualTime for key in keys}
    return (shares, executedShares)


# Obtém tarefas desbloqueadas com os filtros
tw = TaskWarrior()
filterString = ' '.join(argv[1:])
tasks = tw.tasks.filter('+UNBLOCKED').filter(filterString).pending()

if len(tasks) <= 0:
    print("Taskless")
    subprocess.run(["task", "ls", filterString])
    quit()

# Obtém todas as tags
tags = set([tag for task in tasks for tag in extract_tags_from(task)])

# Calcula virtual times
virtualTime = {}
tDict = {}
for task in tasks:
    tDict[task['id']] = task
    virtualTime[task['id']] = exp(task['urgency'])

# Calcula executedTime por task
executedTime = {tid: get_duration_on(
            [tDict[tid]['description']] + extract_tags_from(tDict[tid])
            ) for tid in virtualTime.keys()}

executedTimeTag = {tag: get_duration_on([tag]) for tag in tags}

totalTimeTags = sum(executedTimeTag.values())
for _tup in itertools.combinations(tags, 2):
    totalTimeTags -= get_duration_on(list(_tup))

# Retorna next, se o tempo total for inferior a 25min
if totalTimeTags < 25*60:
    print("Little sampled time (",
          int(sum(executedTime.values())/60), "min)", sep='')
    subprocess.run(["task", "next", filterString, "limit:1"])
    quit()

totalVirtualTime = sum(virtualTime.values())

# Calcula virtual time de cada tag
virtualTimeTag = calculate_tag_sum(tags, tDict, virtualTime)
sharesTag, executedSharesTag = get_shares(
        executedTimeTag, virtualTimeTag, totalTimeTags, totalVirtualTime
        )

# Calcula tempos totais
tids = tDict.keys()
correctedExecutedTime = {}
for tid in tids:
    correctedExecutedTime[tid] = (executedTime[tid]+1)
    for tag in extract_tags_from(tDict[tid]):
        correctedExecutedTime[tid] *= executedSharesTag[tag]/sharesTag[tag]

totalExecutedTime = sum(correctedExecutedTime.values())

# Organiza por diferenças
shares, executedShares = get_shares(
        correctedExecutedTime, virtualTime, totalExecutedTime, totalVirtualTime
        )

difference = {
        key: shares[key]-executedShares[key]
        for key in shares.keys()
        }

tids = sorted(difference, key=difference.get, reverse=True)
tid = tids[0]
print("Necessário: ",
      int(shares[tid]*10000)/100, "%",
      sep='')
print("Executado:  ",
      int(executedShares[tid]*10000)/100, "% (corrigido), ",
      int(executedTime[tid]*10000)/100/sum(executedTime.values()), "% (executado), ",
      sep='')

subprocess.run(["task", "ls", str(tid)])
